{"version":3,"file":"index-e65b49c6.js","sources":["../node_modules/vite/dist/client/env.mjs","../node_modules/vite/dist/client/client.mjs","../src/js/main.js"],"sourcesContent":["const context = (() => {\n    if (typeof globalThis !== 'undefined') {\n        return globalThis;\n    }\n    else if (typeof self !== 'undefined') {\n        return self;\n    }\n    else if (typeof window !== 'undefined') {\n        return window;\n    }\n    else {\n        return Function('return this')();\n    }\n})();\n// assign defines\nconst defines = __DEFINES__;\nObject.keys(defines).forEach((key) => {\n    const segments = key.split('.');\n    let target = context;\n    for (let i = 0; i < segments.length; i++) {\n        const segment = segments[i];\n        if (i === segments.length - 1) {\n            target[segment] = defines[key];\n        }\n        else {\n            target = target[segment] || (target[segment] = {});\n        }\n    }\n});\n//# sourceMappingURL=env.mjs.map\n","import '@vite/env';\n\nconst base$1 = __BASE__ || '/';\n// set :host styles to make playwright detect the element as visible\nconst template = /*html*/ `\n<style>\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  width: 800px;\n  color: var(--window-color);\n  margin: 30px auto;\n  padding: 25px 40px;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n</style>\n<div class=\"backdrop\" part=\"backdrop\">\n  <div class=\"window\" part=\"window\">\n    <pre class=\"message\" part=\"message\"><span class=\"plugin\" part=\"plugin\"></span><span class=\"message-body\" part=\"message-body\"></span></pre>\n    <pre class=\"file\" part=\"file\"></pre>\n    <pre class=\"frame\" part=\"frame\"></pre>\n    <pre class=\"stack\" part=\"stack\"></pre>\n    <div class=\"tip\" part=\"tip\">\n      Click outside or fix the code to dismiss.<br>\n      You can also disable this overlay by setting\n      <code part=\"config-option-name\">server.hmr.overlay</code> to <code part=\"config-option-value\">false</code> in <code part=\"config-file-name\">vite.config.js.</code>\n    </div>\n  </div>\n</div>\n`;\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s+\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\n// Allow `ErrorOverlay` to extend `HTMLElement` even in environments where\n// `HTMLElement` was not originally defined.\nconst { HTMLElement = class {\n} } = globalThis;\nclass ErrorOverlay extends HTMLElement {\n    constructor(err, links = true) {\n        var _a;\n        super();\n        this.root = this.attachShadow({ mode: 'open' });\n        this.root.innerHTML = template;\n        codeframeRE.lastIndex = 0;\n        const hasFrame = err.frame && codeframeRE.test(err.frame);\n        const message = hasFrame\n            ? err.message.replace(codeframeRE, '')\n            : err.message;\n        if (err.plugin) {\n            this.text('.plugin', `[plugin:${err.plugin}] `);\n        }\n        this.text('.message-body', message.trim());\n        const [file] = (((_a = err.loc) === null || _a === void 0 ? void 0 : _a.file) || err.id || 'unknown file').split(`?`);\n        if (err.loc) {\n            this.text('.file', `${file}:${err.loc.line}:${err.loc.column}`, links);\n        }\n        else if (err.id) {\n            this.text('.file', file);\n        }\n        if (hasFrame) {\n            this.text('.frame', err.frame.trim());\n        }\n        this.text('.stack', err.stack, links);\n        this.root.querySelector('.window').addEventListener('click', (e) => {\n            e.stopPropagation();\n        });\n        this.addEventListener('click', () => {\n            this.close();\n        });\n    }\n    text(selector, text, linkFiles = false) {\n        const el = this.root.querySelector(selector);\n        if (!linkFiles) {\n            el.textContent = text;\n        }\n        else {\n            let curIndex = 0;\n            let match;\n            fileRE.lastIndex = 0;\n            while ((match = fileRE.exec(text))) {\n                const { 0: file, index } = match;\n                if (index != null) {\n                    const frag = text.slice(curIndex, index);\n                    el.appendChild(document.createTextNode(frag));\n                    const link = document.createElement('a');\n                    link.textContent = file;\n                    link.className = 'file-link';\n                    link.onclick = () => {\n                        fetch(`${base$1}__open-in-editor?file=` + encodeURIComponent(file));\n                    };\n                    el.appendChild(link);\n                    curIndex += frag.length + file.length;\n                }\n            }\n        }\n    }\n    close() {\n        var _a;\n        (_a = this.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this);\n    }\n}\nconst overlayId = 'vite-error-overlay';\nconst { customElements } = globalThis; // Ensure `customElements` is defined before the next line.\nif (customElements && !customElements.get(overlayId)) {\n    customElements.define(overlayId, ErrorOverlay);\n}\n\nconsole.debug('[vite] connecting...');\nconst importMetaUrl = new URL(import.meta.url);\n// use server configuration, then fallback to inference\nconst serverHost = __SERVER_HOST__;\nconst socketProtocol = __HMR_PROTOCOL__ || (importMetaUrl.protocol === 'https:' ? 'wss' : 'ws');\nconst hmrPort = __HMR_PORT__;\nconst socketHost = `${__HMR_HOSTNAME__ || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${__HMR_BASE__}`;\nconst directSocketHost = __HMR_DIRECT_TARGET__;\nconst base = __BASE__ || '/';\nconst messageBuffer = [];\nlet socket;\ntry {\n    let fallback;\n    // only use fallback when port is inferred to prevent confusion\n    if (!hmrPort) {\n        fallback = () => {\n            // fallback to connecting directly to the hmr server\n            // for servers which does not support proxying websocket\n            socket = setupWebSocket(socketProtocol, directSocketHost, () => {\n                const currentScriptHostURL = new URL(import.meta.url);\n                const currentScriptHost = currentScriptHostURL.host +\n                    currentScriptHostURL.pathname.replace(/@vite\\/client$/, '');\n                console.error('[vite] failed to connect to websocket.\\n' +\n                    'your current setup:\\n' +\n                    `  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\\n` +\n                    `  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\\n` +\n                    'Check out your Vite / network configuration and https://vitejs.dev/config/server-options.html#server-hmr .');\n            });\n            socket.addEventListener('open', () => {\n                console.info('[vite] Direct websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.');\n            }, { once: true });\n        };\n    }\n    socket = setupWebSocket(socketProtocol, socketHost, fallback);\n}\ncatch (error) {\n    console.error(`[vite] failed to connect to websocket (${error}). `);\n}\nfunction setupWebSocket(protocol, hostAndPath, onCloseWithoutOpen) {\n    const socket = new WebSocket(`${protocol}://${hostAndPath}`, 'vite-hmr');\n    let isOpened = false;\n    socket.addEventListener('open', () => {\n        isOpened = true;\n    }, { once: true });\n    // Listen for messages\n    socket.addEventListener('message', async ({ data }) => {\n        handleMessage(JSON.parse(data));\n    });\n    // ping server\n    socket.addEventListener('close', async ({ wasClean }) => {\n        if (wasClean)\n            return;\n        if (!isOpened && onCloseWithoutOpen) {\n            onCloseWithoutOpen();\n            return;\n        }\n        console.log(`[vite] server connection lost. polling for restart...`);\n        await waitForSuccessfulPing(protocol, hostAndPath);\n        location.reload();\n    });\n    return socket;\n}\nfunction warnFailedFetch(err, path) {\n    if (!err.message.match('fetch')) {\n        console.error(err);\n    }\n    console.error(`[hmr] Failed to reload ${path}. ` +\n        `This could be due to syntax errors or importing non-existent ` +\n        `modules. (see errors above)`);\n}\nfunction cleanUrl(pathname) {\n    const url = new URL(pathname, location.toString());\n    url.searchParams.delete('direct');\n    return url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = new WeakSet();\nasync function handleMessage(payload) {\n    switch (payload.type) {\n        case 'connected':\n            console.debug(`[vite] connected.`);\n            sendMessageBuffer();\n            // proxy(nginx, docker) hmr ws maybe caused timeout,\n            // so send ping package let ws keep alive.\n            setInterval(() => {\n                if (socket.readyState === socket.OPEN) {\n                    socket.send('{\"type\":\"ping\"}');\n                }\n            }, __HMR_TIMEOUT__);\n            break;\n        case 'update':\n            notifyListeners('vite:beforeUpdate', payload);\n            // if this is the first update and there's already an error overlay, it\n            // means the page opened with existing server compile error and the whole\n            // module script failed to load (since one of the nested imports is 500).\n            // in this case a normal update won't work and a full reload is needed.\n            if (isFirstUpdate && hasErrorOverlay()) {\n                window.location.reload();\n                return;\n            }\n            else {\n                clearErrorOverlay();\n                isFirstUpdate = false;\n            }\n            await Promise.all(payload.updates.map(async (update) => {\n                if (update.type === 'js-update') {\n                    return queueUpdate(fetchUpdate(update));\n                }\n                // css-update\n                // this is only sent when a css file referenced with <link> is updated\n                const { path, timestamp } = update;\n                const searchUrl = cleanUrl(path);\n                // can't use querySelector with `[href*=]` here since the link may be\n                // using relative paths so we need to use link.href to grab the full\n                // URL for the include check.\n                const el = Array.from(document.querySelectorAll('link')).find((e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl));\n                if (!el) {\n                    return;\n                }\n                const newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes('?') ? '&' : '?'}t=${timestamp}`;\n                // rather than swapping the href on the existing tag, we will\n                // create a new link tag. Once the new stylesheet has loaded we\n                // will remove the existing link tag. This removes a Flash Of\n                // Unstyled Content that can occur when swapping out the tag href\n                // directly, as the new stylesheet has not yet been loaded.\n                return new Promise((resolve) => {\n                    const newLinkTag = el.cloneNode();\n                    newLinkTag.href = new URL(newPath, el.href).href;\n                    const removeOldEl = () => {\n                        el.remove();\n                        console.debug(`[vite] css hot updated: ${searchUrl}`);\n                        resolve();\n                    };\n                    newLinkTag.addEventListener('load', removeOldEl);\n                    newLinkTag.addEventListener('error', removeOldEl);\n                    outdatedLinkTags.add(el);\n                    el.after(newLinkTag);\n                });\n            }));\n            notifyListeners('vite:afterUpdate', payload);\n            break;\n        case 'custom': {\n            notifyListeners(payload.event, payload.data);\n            break;\n        }\n        case 'full-reload':\n            notifyListeners('vite:beforeFullReload', payload);\n            if (payload.path && payload.path.endsWith('.html')) {\n                // if html file is edited, only reload the page if the browser is\n                // currently on that page.\n                const pagePath = decodeURI(location.pathname);\n                const payloadPath = base + payload.path.slice(1);\n                if (pagePath === payloadPath ||\n                    payload.path === '/index.html' ||\n                    (pagePath.endsWith('/') && pagePath + 'index.html' === payloadPath)) {\n                    location.reload();\n                }\n                return;\n            }\n            else {\n                location.reload();\n            }\n            break;\n        case 'prune':\n            notifyListeners('vite:beforePrune', payload);\n            // After an HMR update, some modules are no longer imported on the page\n            // but they may have left behind side effects that need to be cleaned up\n            // (.e.g style injections)\n            // TODO Trigger their dispose callbacks.\n            payload.paths.forEach((path) => {\n                const fn = pruneMap.get(path);\n                if (fn) {\n                    fn(dataMap.get(path));\n                }\n            });\n            break;\n        case 'error': {\n            notifyListeners('vite:error', payload);\n            const err = payload.err;\n            if (enableOverlay) {\n                createErrorOverlay(err);\n            }\n            else {\n                console.error(`[vite] Internal Server Error\\n${err.message}\\n${err.stack}`);\n            }\n            break;\n        }\n        default: {\n            const check = payload;\n            return check;\n        }\n    }\n}\nfunction notifyListeners(event, data) {\n    const cbs = customListenersMap.get(event);\n    if (cbs) {\n        cbs.forEach((cb) => cb(data));\n    }\n}\nconst enableOverlay = __HMR_ENABLE_OVERLAY__;\nfunction createErrorOverlay(err) {\n    if (!enableOverlay)\n        return;\n    clearErrorOverlay();\n    document.body.appendChild(new ErrorOverlay(err));\n}\nfunction clearErrorOverlay() {\n    document\n        .querySelectorAll(overlayId)\n        .forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n    return document.querySelectorAll(overlayId).length;\n}\nlet pending = false;\nlet queued = [];\n/**\n * buffer multiple hot updates triggered by the same src change\n * so that they are invoked in the same order they were sent.\n * (otherwise the order may be inconsistent because of the http request round trip)\n */\nasync function queueUpdate(p) {\n    queued.push(p);\n    if (!pending) {\n        pending = true;\n        await Promise.resolve();\n        pending = false;\n        const loading = [...queued];\n        queued = [];\n        (await Promise.all(loading)).forEach((fn) => fn && fn());\n    }\n}\nasync function waitForSuccessfulPing(socketProtocol, hostAndPath, ms = 1000) {\n    const pingHostProtocol = socketProtocol === 'wss' ? 'https' : 'http';\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        try {\n            // A fetch on a websocket URL will return a successful promise with status 400,\n            // but will reject a networking error.\n            // When running on middleware mode, it returns status 426, and an cors error happens if mode is not no-cors\n            await fetch(`${pingHostProtocol}://${hostAndPath}`, {\n                mode: 'no-cors',\n            });\n            break;\n        }\n        catch (e) {\n            // wait ms before attempting to ping again\n            await new Promise((resolve) => setTimeout(resolve, ms));\n        }\n    }\n}\nconst sheetsMap = new Map();\n// all css imports should be inserted at the same position\n// because after build it will be a single css file\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n    let style = sheetsMap.get(id);\n    if (!style) {\n        style = document.createElement('style');\n        style.setAttribute('type', 'text/css');\n        style.setAttribute('data-vite-dev-id', id);\n        style.textContent = content;\n        if (!lastInsertedStyle) {\n            document.head.appendChild(style);\n            // reset lastInsertedStyle after async\n            // because dynamically imported css will be splitted into a different file\n            setTimeout(() => {\n                lastInsertedStyle = undefined;\n            }, 0);\n        }\n        else {\n            lastInsertedStyle.insertAdjacentElement('afterend', style);\n        }\n        lastInsertedStyle = style;\n    }\n    else {\n        style.textContent = content;\n    }\n    sheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n    const style = sheetsMap.get(id);\n    if (style) {\n        document.head.removeChild(style);\n        sheetsMap.delete(id);\n    }\n}\nasync function fetchUpdate({ path, acceptedPath, timestamp, explicitImportRequired, }) {\n    const mod = hotModulesMap.get(path);\n    if (!mod) {\n        // In a code-splitting project,\n        // it is common that the hot-updating module is not loaded yet.\n        // https://github.com/vitejs/vite/issues/721\n        return;\n    }\n    let fetchedModule;\n    const isSelfUpdate = path === acceptedPath;\n    // determine the qualified callbacks before we re-import the modules\n    const qualifiedCallbacks = mod.callbacks.filter(({ deps }) => deps.includes(acceptedPath));\n    if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n        const disposer = disposeMap.get(acceptedPath);\n        if (disposer)\n            await disposer(dataMap.get(acceptedPath));\n        const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n        try {\n            fetchedModule = await import(\n            /* @vite-ignore */\n            base +\n                acceptedPathWithoutQuery.slice(1) +\n                `?${explicitImportRequired ? 'import&' : ''}t=${timestamp}${query ? `&${query}` : ''}`);\n        }\n        catch (e) {\n            warnFailedFetch(e, acceptedPath);\n        }\n    }\n    return () => {\n        for (const { deps, fn } of qualifiedCallbacks) {\n            fn(deps.map((dep) => (dep === acceptedPath ? fetchedModule : undefined)));\n        }\n        const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n        console.debug(`[vite] hot updated: ${loggedPath}`);\n    };\n}\nfunction sendMessageBuffer() {\n    if (socket.readyState === 1) {\n        messageBuffer.forEach((msg) => socket.send(msg));\n        messageBuffer.length = 0;\n    }\n}\nconst hotModulesMap = new Map();\nconst disposeMap = new Map();\nconst pruneMap = new Map();\nconst dataMap = new Map();\nconst customListenersMap = new Map();\nconst ctxToListenersMap = new Map();\nfunction createHotContext(ownerPath) {\n    if (!dataMap.has(ownerPath)) {\n        dataMap.set(ownerPath, {});\n    }\n    // when a file is hot updated, a new context is created\n    // clear its stale callbacks\n    const mod = hotModulesMap.get(ownerPath);\n    if (mod) {\n        mod.callbacks = [];\n    }\n    // clear stale custom event listeners\n    const staleListeners = ctxToListenersMap.get(ownerPath);\n    if (staleListeners) {\n        for (const [event, staleFns] of staleListeners) {\n            const listeners = customListenersMap.get(event);\n            if (listeners) {\n                customListenersMap.set(event, listeners.filter((l) => !staleFns.includes(l)));\n            }\n        }\n    }\n    const newListeners = new Map();\n    ctxToListenersMap.set(ownerPath, newListeners);\n    function acceptDeps(deps, callback = () => { }) {\n        const mod = hotModulesMap.get(ownerPath) || {\n            id: ownerPath,\n            callbacks: [],\n        };\n        mod.callbacks.push({\n            deps,\n            fn: callback,\n        });\n        hotModulesMap.set(ownerPath, mod);\n    }\n    const hot = {\n        get data() {\n            return dataMap.get(ownerPath);\n        },\n        accept(deps, callback) {\n            if (typeof deps === 'function' || !deps) {\n                // self-accept: hot.accept(() => {})\n                acceptDeps([ownerPath], ([mod]) => deps === null || deps === void 0 ? void 0 : deps(mod));\n            }\n            else if (typeof deps === 'string') {\n                // explicit deps\n                acceptDeps([deps], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n            }\n            else if (Array.isArray(deps)) {\n                acceptDeps(deps, callback);\n            }\n            else {\n                throw new Error(`invalid hot.accept() usage.`);\n            }\n        },\n        // export names (first arg) are irrelevant on the client side, they're\n        // extracted in the server for propagation\n        acceptExports(_, callback) {\n            acceptDeps([ownerPath], ([mod]) => callback === null || callback === void 0 ? void 0 : callback(mod));\n        },\n        dispose(cb) {\n            disposeMap.set(ownerPath, cb);\n        },\n        prune(cb) {\n            pruneMap.set(ownerPath, cb);\n        },\n        // Kept for backward compatibility (#11036)\n        // @ts-expect-error untyped\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        decline() { },\n        // tell the server to re-perform hmr propagation from this module as root\n        invalidate(message) {\n            notifyListeners('vite:invalidate', { path: ownerPath, message });\n            this.send('vite:invalidate', { path: ownerPath, message });\n            console.debug(`[vite] invalidate ${ownerPath}${message ? `: ${message}` : ''}`);\n        },\n        // custom events\n        on(event, cb) {\n            const addToMap = (map) => {\n                const existing = map.get(event) || [];\n                existing.push(cb);\n                map.set(event, existing);\n            };\n            addToMap(customListenersMap);\n            addToMap(newListeners);\n        },\n        send(event, data) {\n            messageBuffer.push(JSON.stringify({ type: 'custom', event, data }));\n            sendMessageBuffer();\n        },\n    };\n    return hot;\n}\n/**\n * urls here are dynamic import() urls that couldn't be statically analyzed\n */\nfunction injectQuery(url, queryToInject) {\n    // skip urls that won't be handled by vite\n    if (!url.startsWith('.') && !url.startsWith('/')) {\n        return url;\n    }\n    // can't use pathname from URL since it may be relative like ../\n    const pathname = url.replace(/#.*$/, '').replace(/\\?.*$/, '');\n    const { search, hash } = new URL(url, 'http://vitejs.dev');\n    return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ''}${hash || ''}`;\n}\n\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };\n//# sourceMappingURL=client.mjs.map\n","const button = document.querySelector(\"button\");\r\nlet answer;\r\nconsole.log(\"hi\");\r\n\r\nbutton.addEventListener(\"click\", async () => {\r\n\tconsole.log(\"hi\");\r\n});\r\n"],"names":["context","defines","key","segments","target","i","segment","base$1","template","fileRE","codeframeRE","HTMLElement","ErrorOverlay","err","links","_a","hasFrame","message","file","e","selector","text","linkFiles","el","curIndex","match","index","frag","link","overlayId","customElements","importMetaUrl","serverHost","socketProtocol","hmrPort","socketHost","directSocketHost","base","messageBuffer","socket","fallback","setupWebSocket","currentScriptHostURL","currentScriptHost","error","protocol","hostAndPath","onCloseWithoutOpen","isOpened","data","handleMessage","wasClean","waitForSuccessfulPing","warnFailedFetch","path","cleanUrl","pathname","url","isFirstUpdate","outdatedLinkTags","payload","sendMessageBuffer","notifyListeners","hasErrorOverlay","clearErrorOverlay","update","queueUpdate","fetchUpdate","timestamp","searchUrl","newPath","resolve","newLinkTag","removeOldEl","pagePath","payloadPath","fn","pruneMap","dataMap","enableOverlay","createErrorOverlay","event","cbs","customListenersMap","cb","n","pending","queued","p","loading","ms","pingHostProtocol","acceptedPath","explicitImportRequired","mod","hotModulesMap","fetchedModule","isSelfUpdate","qualifiedCallbacks","deps","disposer","disposeMap","acceptedPathWithoutQuery","query","dep","loggedPath","msg","button"],"mappings":"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","x_google_ignoreList":[0,1]}